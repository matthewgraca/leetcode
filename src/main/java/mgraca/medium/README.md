# Longest Substring Without Repeating Characters
## Sliding Window
This implementation uses a method called the "sliding window". This approach generally scans an array by forming a "window" around a group of contiguous elements. This comes in handy when you need to check the next element in an array, but may need to discard previous elements based off of what the next element is.\

As a discrete example, find the largest sum of 5 consecutive numbers in an array of integers, of size 20.\
The naive approach would have you sum every element from a[0] to a[4], then a[1] to a[5], then a[2] to a[6], etc., and compare those sums to the current max sum.\
![naive solution](https://i.stack.imgur.com/2Dneo.png)\
However, by utilizing the sliding window and the observation that you are summing numbers you've already summed, what you can do is:
- Sum a[0] to a[4]
- Subtract a[0], add a[5], compare sums
- Subtract a[1], add a[6], compare sums
- etc...\

![sliding window](https://i.stack.imgur.com/zsGl7.png)\
This way, you aren't summing the same numbers over and over again; and as you iterate through the array, you are moving the left window and the right window that constitute the indeces of the array.

For more information and a fantastic visual example, see [this](https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples/64111403#64111403)

# Container With Most Water
## How do you prune irrelevant solutions?
This implementation was a pain to understand, so here's my attempt to break it down. Note, when `height[left] < height[right]`, we can know for certain that `height[right-1], height[right-2] ... height[left+1]` will **ALWAYS** produce an area smaller than the current max generated by `height[left]` and `height[right]`.\

Why? Because if the following heights are larger, they will still use `height[left]` as the height for area calculations, but now with a smaller width (thus always smaller). If the following heights are smaller, then not only will the height decrease, but the width will decrease as well. Since area is a function of height and width and both are decreasing, there is no way that both decreasing will generate a larger area.\

Now, consider when `height[left] >= height[right]`. The same story plays out, but this time we move the right index. By incrementing through from the left, if the heights are larger, the same height of `height[right]` will be used, but with a smaller width. If the heights are smaller, we now have smaller heights and widths, assuredly resulting in smaller areas.\

So, what does this tell us? that when `height[left] < height[right]`, EVERY solution that involves moving the right index but keeping the left index in place will produce a smaller area. Thus, the only way we could find a better solution is if we move the left index. The same kind of story plays out when `height[left] >= height[right]`; this time, keeping the right index in place and moving left will not produce larger areas, thus we must move the right index to search for larger heights.\
