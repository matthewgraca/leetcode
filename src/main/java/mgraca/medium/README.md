# Longest Substring Without Repeating Characters
## Sliding Window
This implementation uses a method called the "sliding window". This approach generally scans an array by forming a "window" around a group of contiguous elements. This comes in handy when you need to check the next element in an array, but may need to discard previous elements based off of what the next element is.

As a discrete example, find the largest sum of 5 consecutive numbers in an array of integers, of size 20. The naive approach would have you sum every element from a[0] to a[4], then a[1] to a[5], then a[2] to a[6], etc., and compare those sums to the current max sum.\
![naive solution](https://i.stack.imgur.com/2Dneo.png)\
However, by utilizing the sliding window and the observation that you are summing numbers you've already summed, what you can do is:
- Sum a[0] to a[4]
- Subtract a[0], add a[5], compare sums
- Subtract a[1], add a[6], compare sums
- etc...

![sliding window](https://i.stack.imgur.com/zsGl7.png)\
This way, you aren't summing the same numbers over and over again; and as you iterate through the array, you are moving the left window and the right window that constitute the indeces of the array.

For more information and a fantastic visual example, see [this](https://stackoverflow.com/questions/8269916/what-is-sliding-window-algorithm-examples/64111403#64111403)

# Container With Most Water
## How do you prune irrelevant solutions?
This implementation was a pain to understand, so here's my attempt to break it down. Note, when `height[left] < height[right]`, we can know for certain that `height[right-1], height[right-2] ... height[left+1]` will **ALWAYS** produce an area smaller than the current max generated by `height[left]` and `height[right]`.

Why? Because if the following heights are larger, they will still use `height[left]` as the height for area calculations, but now with a smaller width (thus always smaller). If the following heights are smaller, then not only will the height decrease, but the width will decrease as well. Since area is a function of height and width and both are decreasing, there is no way that both decreasing will generate a larger area.

Now, consider when `height[left] >= height[right]`. The same story plays out, but this time we move the right index. By incrementing through from the left, if the heights are larger, the same height of `height[right]` will be used, but with a smaller width. If the heights are smaller, we now have smaller heights and widths, assuredly resulting in smaller areas.

So, what does this tell us? that when `height[left] < height[right]`, EVERY solution that involves moving the right index but keeping the left index in place will produce a smaller area. Thus, the only way we could find a better solution is if we move the left index. The same kind of story plays out when `height[left] >= height[right]`; this time, keeping the right index in place and moving left will not produce larger areas, thus we must move the right index to search for larger heights.

# Backtracking
## When to use backtracking
This is an effective heuristic for whenever you need to evaluate all the possible combinations of a solution. What makes this special over a brute force solution is that by adding the right base case (this is a recursive solution), you can effectively prune a huge amount of redundant or invalid combinations.

So while the the stack trace of a backtracking solution looks like a huge tree, it doesn't visit the nodes of invalid solutions (which are the leaves in this case); indeed, you can prune a huge amount of the tree if algorithm can determine early on that a combination that it is currently building will never generate a solution.

Some of the key findings I gathered coding for backtracking:
1. Append to the current solution
2. Backtrack. 
    - If the current solution is valid (can build towards a full solution), the recursion continues. This will then either hit the base case to generate a valid solution, or hit an invalid solution. In which case...
    - If the current solution is invalid, it simply returns.
3. Remove appended solution; because if we reached this point, the current solution won't produce a valid solution, so we kill the tree here and don't bother evaluating beyond this point.

Note: conceptually the recursion is a form of depth-first search, just with early termination!

Example: this is what the stack trace looks like for Q22. Followed in DFS manner

![backtracking](https://assets.leetcode.com/users/images/dabefcea-2a30-4a0a-81c4-b2dafcf9dce0_1599242411.2652733.png)
